IMPORTANT: IN ORDER TO MAKE THE POLL LOOK LIKE THE WEBSOCKET API, WE NEED TO
_NOT_ RESEND MESSAGES AFTER PREMATURE DISCONNECTION IT SEEMS - ACCORDING TO
TESTS, WHAT HAPPENS WHEN A WEBSOCKET BREAKS DOWN, IS THAT IT WILL _NOT_ RESEND
"LOST" MESSAGES...
THIS IS AT LEAST WHAT SEEMS TO HAPPEN FROM THE FRONTEND PERSPECTIVE

So what needs to be done?

Should Sock.it try to reconnect, after a lost connection?
What does WebSocket do?

A lost connection is not a big problem for poll, as it basically is what happens
all the time.
We just need to make sure, no messages is lost in a non-controlled disconnection.

So, this should be the POLL flow:

Message flow
- A message comes in from the browser
- A Sock.it process accepts it
- Sock.it throws it into the Redis "queue" with a timestamp
- Sends a pub/sub message

Poll start flow
- A browser asks for poll-start or doesn't have a connId
- The accepting Sock.it replies with a connId and poll-start
    maybe we should have a success/error message instead?
- The accepting Sock.it adds the user to Redis, including a timestamp
    Question: do we really wanna do this? Does it do anything good? Security?
    Thought: Without, it would just work like websockets, which also has an id

Poll flow
- A browser asks for poll and has a connId
- The accepting sock.it established the connection (updates the user in Redis?)
- The accepting sock.it checks for available messages for the given connId
    Without any "marks"
- If any messages (requests) is available, it marks them "in progress"
- Otherwise it waits for messages to become available (start listening to pub/subs)
- For each message (requests) it makes all the necessary api lookups to get the data
- Send back reply
- If eveything worked, delete the marked messages otherwise remove the mark
- If the connection die prematurely, unmark the messages in Redis and send a pub/sub


We need to have a way of cleaning up messages, that was never unmarked or deleted
due to crashing processes and the likes.

We also need to remove users, if we are to hold them in Redis.
We wont know, when they quit requesting.

Basically we can assume, they should at least be updated each 30-60 sec. as each
request should time out @ ~25 sec, unless something is being send.


From the browsers standpoint, it should just re-connect, when the connection is
closed by the server, right?

This would be the easiest way to ensure, there is no data being sent.

Will this give any problems with connections there aren't being seen as closed?
It shouldn't be a problem, but not sure...


It would be of very great help, if everything concerning closing the connection
could be handled by the server - that way, we know when to close the connection
and that any premature disconnections is the same as an error - in which case
any messages should be unmarked, so the can be handled by someone else.


The marking of messages should probably just be done, by moving a message from
the "active" list to a "in progress" list.



What's similar but different enough, to have code seperated out:

Everything conserned with the clients - we will fall back to poll-start under
default circumstances, but under multi-process/redis setup, we need to be able
to lookup and add the user to redis (unless we start relying on the connId).

We need to change the way messages is received - this will be through redis,
when using that.

Note: We could check if this process actually hold the poll session...

The way messages are sent, is also different.

So:
poll-start -> ask relay to "create" the user
poll-msg -> ask relay to deliver through existing or throw poll-start
poll -> tell relay to establish the connection

What about listening for messages, when using the redis relay?
Maybe just let it be an "internal secret", that it happens at all?

And what about actually sending a message - shouldn't that be relay as well?